package com.sist.main;
/*
 * 1. 객체와 클래스에 대한 설명으로 틀린 것은 무엇입니까?
   1) 클래스는 객체를 생성하기 위한 설계도(청사진)와 같은 것이다.
   2) new 연산자로 클래스의 생성자를 호출함으로써 객체가 생성된다.
   --------------------------------------------------------------------------
   3) 하나의 클래스로 하나의 객체만 생성할 수 있다. => new를 이용하면 여러 개의 객체 생성이 가능
   --------------------------------------------------------------------------
   4) 객체는 클래스의 인스턴스이다.
   
      클래스 제작
      {
          ------
          ------
          ------ 객체를 활용하기 위한 설계
      }
      
      class A
      {
      }
      
      new A()  ---------
                변수
                메소드
               --------- => 저장된 상태 인스턴스 ==> 받아서 활용 (객체) ==> 118page
               
                
   2. 클래스의 구성 멤버가 아닌 것은 무엇입니까?
   ------------------------------------
   => 다른 클래스에서도 사용이 가능 => 객체 지향 (여러개 클래스를 만들어서 조립 => 클래스간의 연관관계)
   1) 필드(field)
   2) 생성자(constructor)
   3) 메소드(method)
   ------------------------------------ 접근 지정어 , 옵션 (static , final , abstract)
   ------------------------------------
   4) 로컬 변수(local variable) => 유일하게 사용하는 옵션 => final만 사용이 가능
   ------------------------------------
      클래스의 구성요소
      ----------------
        멤버변수 => 필드
      ----------------
        생성자
      ----------------
        메소드 => 안에 선언 => 지역변수 (접근지정어가 필요없다)  
      ----------------
      
   3. 필드, 생성자, 메소드에 대한 설명으로 틀린 것은 무엇입니까?
   1) 필드는 객체의 데이터를 저장한다.
   2) 생성자는 객체의 초기화를 담당한다.
   3) 메소드는 객체의 동작 부분으로, 실행 코드를 가지고 있는 블록이다.
      메소드()
      {
         --------
          실행 코드
         --------
      }
   ---------------------------------------------------
   4) 클래스는 반드시 필드와 메소드를 가져야 한다.
   ---------------------------------------------------
     1. 클래스의 종류
        = 데이터형 클래스 : 사용자정의 데이터형 => 관련된 데이터를 한번에 모아서 전송 => 웹
           => 변수만 설정
           class Student
           {
               String name;
               String subject;
               ...
               ...
           }
           
        = 액션 클래스 : 동작
           => 메소드만 설정 
        ------------------------ + 혼합   
        
        멤버변수 : 데이터를 저장할 목적
        메소드 : 멤버변수 활용 => 동작
        생성자 : 멤버변수의 초기화 , 객체 생성자에 호출
    
    4. 필드에 대한 설명으로 틀린 것은 무엇입니까?
    1) 필드는 메소드에서 사용할 수 있다.
    2) 인스턴스 필드 초기화는 생성자에서 할 수 있다.
    -----------------------------------------------------
    3) 필드는 반드시 생성자 선언 전에 선언되어야 한다. => 위치는 상관없다
    -----------------------------------------------------
    4) 필드는 초기값을 주지 않더라고 기본값으로 자동 초기화된다.
    
    1. 멤버변수
        => 초기화 (생성자)
        => 활용 => 메소드
        => 기본값을 가지고 있다
           class A
           {
              int a; ===> 0
              double b; ==> 0.0
              boolean c; ==> false
              String d; ==> null
           } 
           
           class A
           {
              ----------------------
                멤버변수 (필드)
              ----------------------
                생성자
              ----------------------
                메소드  --------------------> 권장사항 => 대부분의 개발자
              ----------------------
           }
           
           class A
           {
              -----------------
               메소드
              -----------------
               생성자
              -----------------
               멤버변수
              -----------------
           }
    
    5. 생성자에 대한 설명으로 틀린 것은 무엇입니까?
    --------------------------------------------------
    1) 객체를 생성하려면 생성자 호출이 반드시 필요한 것은 아니다.
       new 없이 메모리 할당이 가능 => 리플렉션 
    --------------------------------------------------
    2) 생성자는 다른 생성자를 호출하기 위해 this()를 사용할 수 있다.
    3) 생성자가 선언되지 않으면 컴파일러가 기본 생성자를 추가한다. => 매개변수가 없는 생성자
    4) 외부에서 객체를 생성할 수 없도록 생성자에 private 접근 제한자를 붙일 수 있다.
    
    생성자 => 여러개 사용이 가능 , 없는 경우도 존재 (자동 컴파일러에 의해 추가된다)
                                        => 한개라도 존재하면 추가하지 않는다
    class A
    {
    생성자 3개
       A(){} => 매개변수가 없는 생성자만 추가 => 디폴트 생성자 
       A(int a){}
       A(int a,int b){}
    }              

    class A
    {
    생성자 2개
       A(int a){}
       A(int a,int b){}
    }
    
    class A
    {
      => 자동 추가 => A(){}
    }
    
    class A
    {
        A(){}
        A(int a){
          this() => 생성자 호출 
        }
    }
    
    
    
    6. 메소드에 대한 설명으로 틀린 것은 무엇입니까?
    1) 리턴값이 없는 메소드는 리턴 타입을 void로 해야 한다.
    
    2) 리턴 타입이 있는 메소드는 리턴값을 지정하기 위해 반드시 return문이 있어야 한다.
    3) 매개값의 수를 모를 경우 "..."를 이용해서 매개 변수를 선언할 수 있다.
                        -------- 가변 매개변수 printf("%d",1)
                                           printf("%d%d%d",1,2,3)
                                           printf("%d",1)
                                           printf(String s,Object...org)
    ------------------------------------------                                       
    4) 메소드의 이름은 중복해서 선언할 수 없다.
                  ========= 중복 선언이 가능 
    
      메소드는 오버로딩 : 중복 메소드 정의
         1) 메소드명이 동일
         2) 매개변수의 갯수나 데이터형이 다르다
         3) 리턴형은 관계없다
         4) 접근지정어도 관계없다 
         
         void disp()   ==> disp()
         void disp(int a) ==> disp(int)
         int disp(int a, int b) ==> disp(int,int) --
         int disp(double d) => disp(double)         |   => 같은 메소드
         void disp(int c,int k) ==> disp(int,int) --
    ------------------------------------------                                       
    메소드 : 기능 처리
           반복 제거
           재사용
           다른 클래스와 연결
    -------------------------------------
        [접근지정어] 리턴형 메소드명(매개변수목록)
        --------- 다른 클래스와 연결 => public 
        {
            처리문장 => 사용자 요청한 내용 처리
            => 결과값 전송
            return 값;
                   --- 결과값이 없는 경우 => 리턴형 : void , return; , return 생략이 가능
        }

    7. 메소드 오버로딩에 대한 설명으로 틀린 것은 무엇입니까?
    1) 동일한 이름의 메소드를 여러 개 선언하는 것을 말한다.
    ------------------------------------------------
    2) 반드시 리턴 타입이 달라야 한다.
    ------------------------------------------------
    3) 매개 변수의 타입, 수 순서를 다르게 선언해야 한다.
    4) 매개값의 타입 및 수에 따라 호출될 메소드가 선택된다.
    
    void aaa(){}
    void aaa(int a){}
    void aaa(int a, int b){}
    int aaa(double d1,double d2){}
    aaa(10.0,20.0)

    
    
    8. 인스턴스 멤버와 정적 멤버에 대한 설명으로 틀린 것은 무엇입니까?
    1) 정적 멤버는 static으로 선언된 필드와 메소드를 말한다.
       --------------------------------
    ------------------------------------------------   
    2) 인스턴스 필드는 생성자 및 정적 블록에서 초기화될 수 있다. => 정적 블록(X) static 블록(O)
       static과 관련된 메소드 , 초기화 => static 변수, static 메소드만 가능
    ------------------------------------------------   
    3) 정적 필드와 정적 메소드는 객체 생성 없이 클래스를 통해 접근할 수 있다.
       ---------------------------------------------------
    4) 인스턴스 필드와 메소드는 객체를 생성하고 사용해야 한다.
       ---------------------------------------
       
       class A
       {
           static int a=10; ---> 저장
           int b=20; ==> 저장 안됨 
           static void disp(){} --> 저장
           void aaa(){} ==> 저장 안됨
       }
       
       A.a / A.disp()
       클래스명으로 접근이 가능 (변수,메소드) => Math.random()
                                           --------- static
       A aa=new A(); ==> 인스턴스 변수, 메소드가 저장이 된다
         -- b,aaa()
       aa.b , aa.aaa()
       
       class A
       {
          int a=10;
          static int b;
          인스턴스블록
          {
             a,b 초기화가 가능
          }
          static 블록
          static
          {
             b만 초기화 할 수 있다 => static은 static만 초기화
          }
       }                                      


    9. final 필드와 상수(static final)에 대한 설명으로 틀린 것은 무엇입니까?
    1) final 필드와 상수는 초기값이 저장되면 값을 변경할 수 없다.
    ------------------------------------------------
    2) final 필드와 상수는 생성자에서 초기화될 수 있다. => 선언과 동시에 초기값을 부여
    ------------------------------------------------
    3) 상수의 이름은 대문자로 작성하는 것이 관례이다.
                                 ---  
    4) 상수는 객체 생성 없이 클래스를 통해 사용할 수 있다.
       static

    상수 => 상수 (static final) Calendar.YEAR
           상수형 변수 (final) 
    -------------------------------------------------------------------------
    10. 다음 클래스에서 해당 멤버가 필드, 생성자, 메소드 중 어떤 것인지 빈칸을 채우세요.
	public class Member { 
    private String name; // -------------------------------------(  (1)  )  
 
    public Member(String name) { } // ---------------------------(  (2)  )
    
    public void setName(String name) { } // ---------------------(  (3)  )
    }

    




              
                

 */
public class 문제 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
